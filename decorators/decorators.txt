#####################################
# What are decorators in Typescript?
#####################################
-> Decorators are a special kind of declaration that can be attached to class ,method ,accessors, properties or parameters to modify their behavior at runtime.
-> They are functions that are prefixed with @ and are executed when the target (class ,method etc) is declared.
## Think of decorators like annotations or wrappers that add extra features to your class or methods without modifying their actual implementation.

###########################
# When are decorators used?
########################### 
-> Decorators are mostly used in:
   -> Angular (like @Component, @Injectable)
   -> Dependency Injection
   -> Metadata generation
   -> Logging, validation, or authorization
   -> ORMs like TypeORM (@Entity, @Column, etc.)

######################
# Types of decorators 
######################
1. Class Decorator
##################
-> Used to observe,modify or replace a class definition.
Eg: 
function Logger(constructor: Function) {
  console.log("Class created:", constructor.name);
}

@Logger
class Person {
  constructor() {
    console.log("Person created");
  }
}
// Output 
Class created: Person

2. Property Decorator
######################
-> Used to observe or modify a property in a class .
Eg: 
function LogProperty(target: any, propertyKey: string) {
  console.log(`Property decorated: ${propertyKey}`);
}

class Car {
  @LogProperty
  model: string;

  constructor(model: string) {
    this.model = model;
  }
}
// Output
Property decorated: model

3. Method Decorator
####################
-> Used to observe ,modify or replace a method.
Eg: 
function LogMethod(target: any, methodName: string, descriptor: PropertyDescriptor) {
  const original = descriptor.value;

  descriptor.value = function (...args: any[]) {
    console.log(`Method called: ${methodName} with args:`, args);
    return original.apply(this, args);
  };
}

class Calculator {
  @LogMethod
  add(a: number, b: number) {
    return a + b;
  }
} When add(2,3) is called output will be
//Output
Method called: add with args: [2, 3]

4. Accessor Decorator
######################
-> Used on getters and setters.
Eg: 
function LogAccessor(target: any, name: string, descriptor: PropertyDescriptor) {
  console.log(`Accessor decorated: ${name}`);
}

class User {
  private _name: string = "John";

  @LogAccessor
  get name() {
    return this._name;
  }
}

5. Parameter Decorator
#######################
-> Used to access metadata about parameters 
Eg: 
function LogParameter(target: any, methodName: string, parameterIndex: number) {
  console.log(`Parameter in method ${methodName} at index ${parameterIndex} decorated.`);
}

class Message {
  greet(@LogParameter message: string) {
    console.log(message);
  }
}

#######################
‚ö†Ô∏è Enabling Decorators
#######################
You must enable them in tsconfig.json:
Ex: 
{
  "experimentalDecorators": true,
  "emitDecoratorMetadata": true
}

##########################################################################
üéØ Summary Table
##########################################################################
| Decorator Type | Target         | Arguments Received                   |
| -------------- | -------------- | ------------------------------------ |
| Class          | Class          | `constructor: Function`              |
| Property       | Class property | `target: any, propertyKey: string`   |
| Method         | Class method   | `target, methodName, descriptor`     |
| Accessor       | Getter/Setter  | `target, accessorName, descriptor`   |
| Parameter      | Method Param   | `target, methodName, parameterIndex` |
##########################################################################

####################################
# What is decorator factory in TS ?
#################################### 
-> A decorator factory is a function that returns a decorator function.
-> This allows you to pass parameters to you decorator making it configurable or dynamic.

#######################################
# Why do we use a decorator factory ?
#######################################
-> Without a factory :
   -> You cant pass any values to your decorator 
-> With factory : 
   -> You can create reusable decorators that behave differently based on input values 
Syntax: 
function DecoratorFactory(param: any) {
  return function (target: any) {
    // Actual decorator logic
  };
}
// You use it like this: 
@DecoratorFactory("Hello")
class MyClass {}

Example: 
function Logger(message: string) {
  return function (constructor: Function) {
    console.log(`${message} - ${constructor.name}`);
  };
}

@Logger("Creating class")
class Student {
  constructor() {
    console.log("Student instance created");
  }
}
// Output: 
Creating class - Student
Student instance created

################################################################################
üßæ Summary
################################################################################
| Concept           | Explanation                                              |
| ----------------- | -------------------------------------------------------- |
| Decorator Factory | A function that returns a decorator                      |
| Purpose           | To make decorators configurable                          |
| Syntax            | `function factory(...args) { return function (...) {} }` |
| Use cases         | Logging, permissions, metadata, conditional behavior     |
################################################################################

############################
# Using multiple Decorators 
############################
-> In TS you can apply multiple decorators to a class, method ,property or parameter by stacking them one after another.
-> Each decorator is applied in a specific order and may wrap or modify the target differently.
‚úÖ Syntax: 
@FirstDecorator
@SecondDecorator
class MyClass {}
// This is equivalent to : 
MyClass = FirstDecorator(SecondDecorator(MyClass));
-> So decorators are applied from bottom to top(or right to left if inline).

Example:// Multiple class decorator 
function First() {
  return function (constructor: Function) {
    console.log("First decorator executed");
  };
}

function Second() {
  return function (constructor: Function) {
    console.log("Second decorator executed");
  };
}

@First()
@Second()
class TestClass {}

// Output
Second decorator executed
First decorator executed

Example2: // Multiple method decorator
function Log1(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  console.log("Log1 applied on:", propertyKey);
}

function Log2(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  console.log("Log2 applied on:", propertyKey);
}

class Math {
  @Log1
  @Log2
  calculate() {
    return 2 + 2;
  }
}
// Output 
Log2 applied on: calculate  
Log1 applied on: calculate

########
# Note:
########
-> Each decorator can modify or replace the target 
-> If you are using angular this is common: 
####################################
# Execution Order summary 
####################################
-> There are two phases involved: 
1. Decorator factory execution (Top to bottom)
##############################################
-> This is when the outer function (ie @Decorator()) are called to produce decorators 
‚û°Ô∏è Order: Top to Bottom

2. Decorator function execution (Bottom to Top)
-> This is when the actual decorator functions (returned by those factories) are applied to the target.
‚û°Ô∏è Order: Bottom to Top

Example: 
function First() {
  console.log("First factory evaluated");
  return function (target: any) {
    console.log("First decorator executed");
  };
}

function Second() {
  console.log("Second factory evaluated");
  return function (target: any) {
    console.log("Second decorator executed");
  };
}

@First()
@Second()
class Example {}

// Output
First factory evaluated
Second factory evaluated
Second decorator executed
First decorator executed

