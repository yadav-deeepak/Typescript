#####################################
# What are decorators in Typescript?
#####################################
-> Decorators are a special kind of declaration that can be attached to class ,method ,accessors, properties or parameters to modify their behavior at runtime.
-> They are functions that are prefixed with @ and are executed when the target (class ,method etc) is declared.
## Think of decorators like annotations or wrappers that add extra features to your class or methods without modifying their actual implementation.

###########################
# When are decorators used?
########################### 
-> Decorators are mostly used in:
   -> Angular (like @Component, @Injectable)
   -> Dependency Injection
   -> Metadata generation
   -> Logging, validation, or authorization
   -> ORMs like TypeORM (@Entity, @Column, etc.)

######################
# Types of decorators 
######################
1. Class Decorator
##################
-> Used to observe,modify or replace a class definition.
Eg: 
function Logger(constructor: Function) {
  console.log("Class created:", constructor.name);
}

@Logger
class Person {
  constructor() {
    console.log("Person created");
  }
}
// Output 
Class created: Person

2. Property Decorator
######################
-> Used to observe or modify a property in a class .
Eg: 
function LogProperty(target: any, propertyKey: string) {
  console.log(`Property decorated: ${propertyKey}`);
}

class Car {
  @LogProperty
  model: string;

  constructor(model: string) {
    this.model = model;
  }
}
// Output
Property decorated: model

3. Method Decorator
####################
-> Used to observe ,modify or replace a method.
Eg: 
function LogMethod(target: any, methodName: string, descriptor: PropertyDescriptor) {
  const original = descriptor.value;

  descriptor.value = function (...args: any[]) {
    console.log(`Method called: ${methodName} with args:`, args);
    return original.apply(this, args);
  };
}

class Calculator {
  @LogMethod
  add(a: number, b: number) {
    return a + b;
  }
} When add(2,3) is called output will be
//Output
Method called: add with args: [2, 3]

4. Accessor Decorator
######################
-> Used on getters and setters.
Eg: 
function LogAccessor(target: any, name: string, descriptor: PropertyDescriptor) {
  console.log(`Accessor decorated: ${name}`);
}

class User {
  private _name: string = "John";

  @LogAccessor
  get name() {
    return this._name;
  }
}

5. Parameter Decorator
#######################
-> Used to access metadata about parameters 
Eg: 
function LogParameter(target: any, methodName: string, parameterIndex: number) {
  console.log(`Parameter in method ${methodName} at index ${parameterIndex} decorated.`);
}

class Message {
  greet(@LogParameter message: string) {
    console.log(message);
  }
}

#######################
âš ï¸ Enabling Decorators
#######################
You must enable them in tsconfig.json:
Ex: 
{
  "experimentalDecorators": true,
  "emitDecoratorMetadata": true
}

##########################################################################
ðŸŽ¯ Summary Table
##########################################################################
| Decorator Type | Target         | Arguments Received                   |
| -------------- | -------------- | ------------------------------------ |
| Class          | Class          | `constructor: Function`              |
| Property       | Class property | `target: any, propertyKey: string`   |
| Method         | Class method   | `target, methodName, descriptor`     |
| Accessor       | Getter/Setter  | `target, accessorName, descriptor`   |
| Parameter      | Method Param   | `target, methodName, parameterIndex` |
##########################################################################

####################################
# What is decorator factory in TS ?
#################################### 
-> A decorator factory is a function that returns a decorator function.
-> This allows you to pass parameters to you decorator making it configurable or dynamic.

#######################################
# Why do we use a decorator factory ?
#######################################
-> Without a factory :
   -> You cant pass any values to your decorator 
-> With factory : 
   -> You can create reusable decorators that behave differently based on input values 
Syntax: 
function DecoratorFactory(param: any) {
  return function (target: any) {
    // Actual decorator logic
  };
}
// You use it like this: 
@DecoratorFactory("Hello")
class MyClass {}

Example: 
function Logger(message: string) {
  return function (constructor: Function) {
    console.log(`${message} - ${constructor.name}`);
  };
}

@Logger("Creating class")
class Student {
  constructor() {
    console.log("Student instance created");
  }
}
// Output: 
Creating class - Student
Student instance created

################################################################################
ðŸ§¾ Summary
################################################################################
| Concept           | Explanation                                              |
| ----------------- | -------------------------------------------------------- |
| Decorator Factory | A function that returns a decorator                      |
| Purpose           | To make decorators configurable                          |
| Syntax            | `function factory(...args) { return function (...) {} }` |
| Use cases         | Logging, permissions, metadata, conditional behavior     |
################################################################################

############################
# Using multiple Decorators 
############################
-> In TS you can apply multiple decorators to a class, method ,property or parameter by stacking them one after another.
-> Each decorator is applied in a specific order and may wrap or modify the target differently.
âœ… Syntax: 
@FirstDecorator
@SecondDecorator
class MyClass {}
// This is equivalent to : 
MyClass = FirstDecorator(SecondDecorator(MyClass));
-> So decorators are applied from bottom to top(or right to left if inline).

Example:// Multiple class decorator 
function First() {
  return function (constructor: Function) {
    console.log("First decorator executed");
  };
}

function Second() {
  return function (constructor: Function) {
    console.log("Second decorator executed");
  };
}

@First()
@Second()
class TestClass {}

// Output
Second decorator executed
First decorator executed

Example2: // Multiple method decorator
function Log1(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  console.log("Log1 applied on:", propertyKey);
}

function Log2(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  console.log("Log2 applied on:", propertyKey);
}

class Math {
  @Log1
  @Log2
  calculate() {
    return 2 + 2;
  }
}
// Output 
Log2 applied on: calculate  
Log1 applied on: calculate

########
# Note:
########
-> Each decorator can modify or replace the target 
-> If you are using angular this is common: 
####################################
# Execution Order summary 
####################################
-> There are two phases involved: 
1. Decorator factory execution (Top to bottom)
##############################################
-> This is when the outer function (ie @Decorator()) are called to produce decorators 
âž¡ï¸ Order: Top to Bottom

2. Decorator function execution (Bottom to Top)
-> This is when the actual decorator functions (returned by those factories) are applied to the target.
âž¡ï¸ Order: Bottom to Top

Example: 
function First() {
  console.log("First factory evaluated");
  return function (target: any) {
    console.log("First decorator executed");
  };
}

function Second() {
  console.log("Second factory evaluated");
  return function (target: any) {
    console.log("Second decorator executed");
  };
}

@First()
@Second()
class Example {}

// Output
First factory evaluated
Second factory evaluated
Second decorator executed
First decorator executed

#######################
# Property Decorator  
#######################
-> It is a special kind of decorator that is applied to class  properties .
-> It allows you to observe modify or annotate the property of a class at design time(ie; when the class is defined not when its instantiated).
âœ… Syntax of Property Decorator
function PropertyDecorator(target: Object, propertyKey: string | symbol) {
    // logic goes here
}
class Example {
  @PropertyDecorator
  myProperty: string;
}

# Parameters of property decorator function 
############################################
1. target : 
-> For static properties: it is the constructor function of the class
-> For instance properties: it is the prototype of the class 

2. propertyKey : 
-> The name of the property being decorated (as a string or symbol).

Eg: 
function LogProperty(target: any, propertyKey: string) {
    let value = target[propertyKey];

    const getter = () => {
        console.log(`Getting value of ${propertyKey}: ${value}`);
        return value;
    };

    const setter = (newValue: any) => {
        console.log(`Setting value of ${propertyKey} to: ${newValue}`);
        value = newValue;
    };

    Object.defineProperty(target, propertyKey, {
        get: getter,
        set: setter,
        enumerable: true,
        configurable: true
    });
}

class Person {
    @LogProperty
    name: string = "John";
}
const p = new Person();
p.name = "Alice"; // Logs: Setting value of name to: Alice
console.log(p.name); // Logs: Getting value of name: Alice

## Important Notes :
#####################
-> Property decorators dont receive the property value directly .
-> You cant modify the initializer of the property directly using a property decorator 
-> If you wanna intercept or modify behaviour use object.defineProperty inside the decorator 
-> Property decorators can be useful in ORMs, form validation, metadata generation etc.

# Common use cases: 
###################
-> Logging property access or updates 
-> Attaching metadata using Reflect.metadata 
-> Auto binding 
-> Marking properties as required in validation libraries 

##############################
ðŸ“Œ Summary (for quick notes):
##############################
| Aspect           | Detail                                          |
| ---------------- | ----------------------------------------------- |
| Applies to       | Class properties (not methods or parameters)    |
| Parameters       | `(target, propertyKey)`                         |
| Common use cases | Logging, validation, metadata                   |
| Limitation       | Cannot access or modify property value directly |
| Helper library   | Often used with `reflect-metadata`              |
| Runs             | When the class is **defined**, not instantiated |

######################
# Accessor Decorator #
######################
